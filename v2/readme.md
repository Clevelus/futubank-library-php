# Общая часть модулей оплаты

Распространение: чистый копипаст файла `fpayments.php` и частичный копипаст файла `fpayments_config.php`. 
Имена файлов не меняются.

Почему так: модули оплаты могут быть и под довольно древние системы, которые игнорируют PHP7 (привет, Amiro CMS!)
и прочие достижения цивилизации.

Поэтому чем проще, тем лучше.

## Как это работает

Модуль оплаты должен делать три вещи:

1. иметь страницу настроек;
2. уметь перенаправлять пользователя на платёжную страницу;
3. иметь специальный url, на который платёжная система отправит POST-запрос,
чтобы показать, что заказ оплачен.

А теперь подробней.

### Настройки модуля оплаты

Чтобы принимать платежи, у администратора магазина должна быть страница с настройками, где он сможет задать 
следующие параметры:

* `merchant_id`— Merchant ID. Обязательное поле. Берётся из личного кабинета платёжной системы.
* `secret_key` — секретный ключ магазина. Обязательное поле. Берётся из личного кабинета платёжной системы.
* `is_test` — тестовый режим. Значение по умолчанию `false`. В тестовом режиме работать только одна тестовая карта, 
и деньги по-настоящему списываться не будут. Редкая возможность почувствовать себя миллиардером, и «купить» себе 
что-нибудь на абсолютно любую сумму.

Если CMS не содержит данных об НДС (это нужно для электронных чеков), то потребуется поле:

* `nds` — НДС

Возможные значения:
* 1 = без НДС (значение по умолчанию)
* 2 = НДС по ставке 0%
* 3 = НДС чека по ставке 10%
* 4 = НДС чека по ставке 18%
* 5 = НДС чека по расчетной ставке 10/110
* 6 = НДС чека по расчетной ставке 18/118

А если у CMS нету встроенных страниц «всё хорошо, деньги получили» и «что-то пошло не так, платёж не удался» 
(и только в этом случае!), потребуется ещё две настройки:

* `success_url` — адрес страницы «всё хорошо, деньги получили». 
* `fail_url` — адрес страницы «платёж не удался». 

Значения этих двух полей по умолчанию должны быть следующими:
 ```php
$success_url = FPaymentsForm::abs('/success')
$fail_url = FPaymentsForm::abs('/fail');
```

### Как всё это называется?

Название платёжной системы следует брать из `FPaymentsConfig::NAME`. Это красивое название, для человека .

Есть ещё `FPaymentsConfig::PREFIX`. Это латинское название, без пробелов. Для кода, префиксов и т.п. 

Например, для WooCommerce:

```php
class WC_Gateway_MyGateway extends WC_Payment_Gateway {
    function __construct() {
        $this->id = FPaymentsConfig::PREFIX;
        $this->method_title = FPaymentsConfig::NAME;
        // ....
    }
    // ....
}
```

### Проведение платежа

Шаг 1. создаём экземпляр FPaymentsForm:

```php
$form = new FPaymentsForm($merchant_id, $secret_key, $is_test, $plugininfo, $cmsinfo);
```

Значения `$merchant_id`, `$secret_key` и `$is_test` берутся из настроек (см. выше).

Значения `$plugininfo`, `$cmsinfo` нужны для статистики использования модулей оплаты.  В свободной форме там указывается 
название и версия модуля и CMS. 

Например, для Wordpress:
```php
$plugininfo = 'MY_WP_GATEWAY 1.0';
$cmsinfo = 'WordPress ' . get_bloginfo('version');
```

Шаг 2. собираем данные заказа:

```php
$form_data = $form->compose(
     $amount,        // сумма заказа
     $currency,      // валюта заказа (поддерживается только "RUB")
     $order_id,      // номер заказа
     $client_email,  // e-mail клиента (может быть '')
     $client_name,   // имя клиента (может быть '')
     $client_phone,  // телефон клиента (может быть '')
     $success_url,   // URL, куда направить клиента при успешной оплате
     $fail_url,      // URL, куда направить клиента при ошибке
     $cancel_url,    // URL текущей страницы
     $meta,          // дополнительная информация в свободной форме (может быть '')
     $description,   // описание (может быть '')
     
     // данные для электронных чеков
     $receipt_contact,  // контакт (телефон или email) для чеков
     $receipt_items,    // массив элементов чека (см. ниже)
     
     // Следующие 2 поля нужны только для рекуррентных платежей. 
     // Если вы не знаете что это, вам это скорее всего не нужно
     $recurring_frequency = '',    // Частота платежей (необязятельно, один из вариантов 'day', 'week', 'month', 'quartal', 'half-year', 'year')
     $recurring_finish_date = '',  // Конечная дата платежей (необязательно, дата в формате 'YYYY-MM-DD')
);
```

Важные замечания про электронные чеки:

`$receipt_contact` должен быть всегда, и всегда содержать телефон или почту клиента. Иначе не удастся отправить
 электронный чек, и налоговая будет недовольна.  Поля `$client_email` и `$client_phone` при этом могут быть 
 или не быть заполнены, могут совпадать с `$receipt_contact`, а могут не совпадать.
 
`$receipt_items` — самое интересное поле. Это массив объектов `FPaymentsRecieptItem`. И суммарные данные в нём 
должны совпадать со значением `$amount` (иначе вылетит исключение `FPaymentsError`). 

Разберём на примере: заказ бутылка кефира за 99 рублей, три батона по 30, доставка 200 рублей. 99+30*3 + 200 = 389.

```php
$amount = 389;
$currency = 'RUB';
// ....
$receipt_contact = 'test@test.ru';
$receipt_items = array(
    new FPaymentsRecieptItem('Бутылка кефира', 99, 1, $nds),
    new FPaymentsRecieptItem('Батон', 30, 3, $nds),
    new FPaymentsRecieptItem('Доставка', 200),  // если доставка бесплатная, ничего такого не надо
);
// ... 
$form_data = $form->compose($amount, $currency, /* ...... */ $receipt_contact, $receipt_items);
```

Значения `$nds` берётся из настроек модуля оплаты (см. выше). Однако в теории могут быть ситуации, когда на 
разные товары разный НДС. Такими ситуациями пока пренебрегаем.

Шаг 3. Выводим платёжную форму и перенаправляем пользователя на страницу оплаты платёжной системы. 

Это может быть как форма прямо на странице:

```php
echo "<form action='" . $form->get_url() "' method='post'>" . FPaymentsForm::array_to_hidden_fields($form_data) . '<input type="submit"></form>';
```

Так и отдельная промежуточная страница с автоотправкой:

```html
<!DOCTYPE html>
<html>
<head>
	<title>...</title>
	<script type="text/javascript">
	window.onload = function() {
		document.getElementById('autosubmit-form').submit();
	};
	</script>
</head>
<body>
	<form action="<?php echo $form->get_url(); ?>" method="post" id="autosubmit-form">
	    <?php echo FPaymentsForm::array_to_hidden_fields($form_data); ?>
	    <input type="submit" value="Продолжить...">
	</form>
</body>
</html>
```

Вместо вызова `FPaymentsForm::array_to_hidden_fields()` можно самостоятельно отрисовать содержимое `$form_data`
в виде hidden-полей (или не-hidden, для отладки).

Шаг 4. подтверждение платежа

Если пользователь вместо того, чтобы вводить данные карты и нажимать большую зелёную кнопку «оплатить», нажал «назад»,
платёжная система перенаправит его на `$cancel_url`.

Если пользователь ввёл данные, но платёж не прошёл (например, на счету нет денег, или неверно указан номер карты), 
платёжная система перенаправит его на `$fail_url`.

А если всё хорошо, то случится две вещи:

* пользователя перенаправят на `$success_url`
* платёжнная система отправит POST-запрос на адрес обработчика. Адрес задаётся в личном кабинете платёжной системы.
Чтобы пользователь не забыл об этом, адрес обработчика должен выводиться на странце 
настроек текстом-напоминалкой. Например так:
 
```
[Укажите merchant ID]

[Укажите Secret Key]

[x] тестовый режим

Внимание! Для корректной работы модуля оплаты пропишите в личном кабинете в разделе 
«Уведомления об успешных транзакциях» адрес: https//mysite.ru/callback.php
 ```

Внутри у него должен быть примерно следующий код (внимание! это просто заготовка, в реальности у всех CMS всё может
быть по своему):

```php
class MyCallbackHandler extends AbstractFPaymentsCallbackHandle {
    function __construct() {
        // .... 
    }
 
    protected function get_fpayments_form() { 
        // ...
        return new FPaymentsForm($merchant_id, $secret_key, $is_test, $plugininfo, $cmsinfo);
    }
    
    protected function load_order($order_id) { 
        // возвращает объект Order для конкретной CMS. Например, wc_get_order() для WooCommerce
        return ...;
    }
 
    protected function get_order_currency($order) { 
        // возвращает валюту заказа. Например, $order->get_currency() для WooCommerce
        return ...;
    }
    
    protected function get_order_amount($order) { 
        // возвращает сумму заказа. Например, $order->get_total() для WooCommerce
        return ...;
    }
 
    protected function is_order_completed($order) { 
        // оплачен заказ или нет. Например, $order->is_paid() для WooCommerce
        return ...;
    }
    
    protected function mark_order_as_completed($order, array $data) {
        // отмечает заказ оплаченным. Например, $order->payment_complete(); для WooCommerce
    }
    protected function mark_order_as_error($order, array $data) {
        // отмечает заказ ошибочным. Необязательно, но полезно для отладки.
    }
}

// обрабатываем сообщение от банка, пришедшее в _POST, и если всё хорошо, отмечаем заказ как оплаченный
$h = new MyCallbackHandler();
$h->show($_POST); 
```

ВАЖНО! Метод `show` выводит строку `OK` или `ERROR`! Это значение важно для платёжной системы!

Какие с этим могут быть проблемы?

Например в WooCommerce вроде бы есть специальный метод для обработки таких подтверждений платежа от платёжной системы. 
Но он, хотя и вызовет любой ваш код, отдаст запрашивающему контент "-1". А всё, что вы в своём коде вывели, 
очистится с помощью `ob_get_clean()`.

### Для продвинутых пользователей. Можно не читать

Отправка рекуррентного платежа.

```php
$form = new FPaymentsForm($merchant_id, $secret_key, $is_test);
$result = $form->rebill(
    $amount,           // сумма заказа
    $currency,         // валюта заказа (поддерживается только "RUB")
    $order_id,         // номер заказа
    $recurrind_tx_id,  // id транзакции, получен при первом платеже
    $recurring_token,  // токен рекуррентной транзакции, получен при первом платеже
    $description = ''  // описание заказа (необязательно)
);
```
