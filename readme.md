# Общая часть модулей оплаты

В этой директории находится общая часть модулей оплаты FPayments. Основная функциональность: формирование запросов на оплату,
получение информации о транзакции, базовый класс обработчика колбеков от платежной системы.

Распространение: файлы `fpayments.php` и `fpayments_config.php` копируются в проект с модулем оплаты.  Имена файлов не меняются.

## Как это работает

Модуль оплаты должен делать три вещи:

1. иметь страницу настроек;
2. уметь перенаправлять пользователя на платёжную страницу;
3. иметь специальный url, на который платёжная система отправит POST-запрос,
чтобы показать, что заказ оплачен.

А теперь подробней.


### План работы над модулем интеграции

1. Зарегистрировать платежный метод в платформе интернет-магазина
2. Сделать страницу настроек
3. Сделать формирование платежного запроса
4. Сделать страницу успешной/неуспешной оплаты, если не предусмотрено штатных.
5. Сделать обработчик на странице успешной оплаты, меняющий статус заказа.
6. Сделать обработчик HTTP-уведомлений (колбеков) от платежной системы.


### Как всё это называется?

Все классы лежат в пространстве имен FPayments. Полный список импортов:
```php
use FPayments\PaymentForm;
use FPayments\ModuleConfig;
use FPayments\ReceiptItem;
use FPayments\AbstractCallbackHandler;
```

Далее в документе все имена классов будут использоваться без пространства имен.

Название платёжной системы следует брать из `ModuleConfig::NAME`. Это красивое название, для человека .

Есть ещё `ModuleConfig::PREFIX`. Это латинское название, без пробелов. Для кода, префиксов и т.п.

Например, для WooCommerce:

```php
use FPayments\ModuleConfig;

class WC_Gateway_MyGateway extends WC_Payment_Gateway {
    function __construct() {
        $this->id = ModuleConfig::PREFIX;
        $this->method_title = ModuleConfig::NAME;
        // ....
    }
    // ....
}
```

### Страница настроек

Чтобы принимать платежи, у администратора магазина должна быть страница с настройками, где он сможет задать
следующие параметры:

* `merchant_id` — Merchant ID. Обязательное поле. Берётся из личного кабинета платёжной системы.
* `secret_key` — секретный ключ магазина. Обязательное поле. Берётся из личного кабинета платёжной системы.
* `is_test` — тестовый режим. Значение по умолчанию `false`. В тестовом режиме работать только одна тестовая карта,
и деньги по-настоящему списываться не будут. Редкая возможность почувствовать себя миллиардером, и «купить» себе
что-нибудь на абсолютно любую сумму.

### Проведение платежа

Шаг 1. создаём экземпляр PaymentForm:

```php
use FPayments\PaymentForm;

$form = new PaymentForm($merchant_id, $secret_key, $is_test, $plugininfo, $cmsinfo);
```

Значения `$merchant_id`, `$secret_key` и `$is_test` берутся из настроек (см. выше).

Значения `$plugininfo`, `$cmsinfo` нужны для статистики использования модулей оплаты.  В свободной форме там указывается
название и версия модуля и CMS.

Например, для Wordpress:
```php
$plugininfo = 'MY_WP_GATEWAY 1.0';
$cmsinfo = 'WordPress ' . get_bloginfo('version');
```

Шаг 2. собираем данные заказа:

```php
$form_data = $form->compose(
     $amount,        // сумма заказа
     $currency,      // валюта заказа (поддерживается только "RUB")
     $order_id,      // номер заказа
     $client_email,  // e-mail клиента (может быть '')
     $client_name,   // имя клиента (может быть '')
     $client_phone,  // телефон клиента (может быть '')
     $success_url,   // URL, куда направить клиента при успешной оплате
     $fail_url,      // URL, куда направить клиента при ошибке
     $cancel_url,    // URL, куда направить клиентав при нажатии на кнопку "возврат" на платежной форме
     $callback_url,  // URL обработчика уведомлений от платежной системы (колбеки)
     $meta,          // дополнительная информация в свободной форме (формат - сериализованный JSON. Может быть '')
     $description,   // описание (может быть '')

     // данные для электронных чеков
     $receipt_contact,  // контакт (телефон или email) для отправки чека
     $receipt_items,    // массив элементов чека (см. ниже)

     // Следующие 2 поля нужны только для рекуррентных (периодических) платежей.
     $recurring_frequency = '',    // Частота платежей (один из вариантов 'day', 'week', 'month', 'quartal', 'half-year', 'year')
     $recurring_finish_date = '',  // Конечная дата платежей (дата в формате 'YYYY-MM-DD')
);
```

Важные замечания про электронные чеки:

1. `$receipt_contact` должен быть всегда, и всегда содержать телефон или почту клиента. Значение может не совпадать с содержимым `$client_phone` и `$client_email`.

2. `$receipt_items` — массив объектов `\FPayments\ReceiptItem`. И суммарные данные в нём должны совпадать со значением `$amount` (иначе вылетит исключение `FormError`).

Разберём на примере: заказ бутылка кефира за 99 рублей, три батона по 30, доставка 200 рублей. 99+30*3 + 200 = 389.

```php
use \FPayments\ReceiptItem;

$amount = 389;
$currency = 'RUB';
// ....
$receipt_contact = 'test@test.ru';
$receipt_items = array(
    new ReceiptItem('Бутылка кефира', 99, 1, 'vat18'),
    new ReceiptItem('Батон', 30, 'vat18'),
    new ReceiptItem('Доставка', 200, 'vat18'),
);
// ...
$form_data = $form->compose($amount, $currency, /* ...... */ $receipt_contact, $receipt_items);
```

Аргументы объекта `ReceiptItem`:

  1. Название продукта
  2. Стоимость за единицу
  3. Количество (по умолчанию 1). Может быть дробным числом.
  4. Ставка НДС. По умолчанию `none`.


Код НДС необходимо взять из свойств товара. Возможные значения этого поля:

* `none` = без НДС (значение по умолчанию)
* `vat0` = НДС по ставке 0%
* `vat10` = НДС чека по ставке 10%
* `vat18` = НДС чека по ставке 18%
* `vat110` = НДС чека по расчетной ставке 10/110
* `vat118` = НДС чека по расчетной ставке 18/118

В случае, когда ставка налога задана в виде числа (напр `18.000`), то можно воспользоваться функцией ReceiptItem::guess_vat($rate),
чтобы получить код ставки.

Шаг 3. Выводим платёжную форму и перенаправляем пользователя на страницу оплаты платёжной системы.

Это может быть как форма прямо на странице:

```php
echo "<form action='" . $form->get_url() "' method='post'>" . PaymentForm::array_to_hidden_fields($form_data) . '<input type="submit"></form>';
```

Так и отдельная промежуточная страница с автоотправкой:

```html
<!DOCTYPE html>
<html>
<head>
	<title>...</title>
	<script type="text/javascript">
	window.onload = function() {
		document.getElementById('autosubmit-form').submit();
	};
	</script>
</head>
<body>
	<form action="<?php echo $form->get_url(); ?>" method="post" id="autosubmit-form">
            <?php echo PaymentForm::array_to_hidden_fields($form_data); ?>
            <input type="submit" value="Продолжить...">
	</form>
</body>
</html>
```

Вместо вызова `PaymentForm::array_to_hidden_fields()` можно самостоятельно отрисовать содержимое `$form_data`
в виде hidden-полей (или не-hidden, для отладки).

Шаг 4. подтверждение платежа

Если пользователь вместо того, чтобы вводить данные карты и нажимать большую зелёную кнопку «оплатить», нажал «назад»,
платёжная система перенаправит его на `$cancel_url`.

Если пользователь ввёл данные, но платёж не прошёл (например, на счету нет денег, или неверно указан номер карты),
платёжная система перенаправит его на `$fail_url`.

Если транзакция прошла успешно, то пользователь будет перенаправлен на страницу `$success_url`.


Шаг №5. Изменение статуса заказа.

Статус заказа меняется в одном или двух местах, в зависимости от CMS.

1. При получении HTTP-уведомления (колбека) от платежной системы на адрес `$callback_url`.
2. В обработчике `$success_url`, если в CMS для нормальной работы требуется знать статус заказа
   сразу при возвращении клиента от платежной системы.


##### Обработка колбека

Платежная система отправляет запрос со статусом транзакции на адрес обработчика (`$callback_url`).
Запросы приходят всегда в случае успешной транзакции, и только при указании опции `callback_on_failure` в случае ошибки
(`$payment_form->enable_callback_on_failure()`).

Платежная система ожидает ответ определенного формата от обработчика (вида `OK <order_id>`. Подробнее см. ниже).

Внутри обработчика должен быть примерно следующий код (внимание! это просто заготовка, в реальности у всех CMS всё может
быть по своему):

```php
class MyCallbackHandler extends AbstractCallbackHandler {
    function __construct() {
        // ....
    }

    protected function get_fpayments_form() {
        // ...
        return new PaymentForm($merchant_id, $secret_key, $is_test, $plugininfo, $cmsinfo);
    }

    protected function load_order($order_id) {
        // возвращает объект Order для конкретной CMS. Например, wc_get_order() для WooCommerce
        return ...;
    }

    protected function get_order_currency($order) {
        // возвращает валюту заказа. Например, $order->get_currency() для WooCommerce
        return ...;
    }

    protected function get_order_amount($order) {
        // возвращает сумму заказа. Например, $order->get_total() для WooCommerce
        return ...;
    }

    protected function is_order_completed($order) {
        // оплачен заказ или нет. Например, $order->is_paid() для WooCommerce
        return ...;
    }

    protected function mark_order_as_completed($order, array $data) {
        // отмечает заказ оплаченным. Например, $order->payment_complete(); для WooCommerce
    }
    protected function mark_order_as_error($order, array $data) {
        // отмечает заказ ошибочным.
    }
}

// обрабатываем сообщение от банка, пришедшее в _POST, и если всё хорошо, отмечаем заказ как оплаченный
$h = new MyCallbackHandler();
$h->show($_POST);
```

ВАЖНО! Метод `show` выводит строку `OK` или `ERROR`! Это значение важно для платёжной системы!

Какие с этим могут быть проблемы?

Например в WooCommerce вроде бы есть специальный метод для обработки таких подтверждений платежа от платёжной системы.
Но он, хотя и вызовет любой ваш код, отдаст запрашивающему контент "-1". А всё, что вы в своём коде вывели,
очистится с помощью `ob_get_clean()`.


##### Изменение статуса в обработчике `$success_url`.

В параметрах к странице успеха передается параметр `transaction_id`,
используя который необходимо сделать запрос в платежную систему, чтобы получить статус транзакции
(`$form->get_transaction_info($id)`). После этого необходимо сверить идентификатор заказа, сумму,
убедиться что транзакция успешна (state=COMPLETE), и поменять статус заказа.



### Для продвинутых пользователей. Можно не читать

##### Отправка рекуррентного платежа.

```php
$form = new PaymentForm($merchant_id, $secret_key, $is_test);
$result = $form->rebill(
    $amount,           // сумма заказа
    $currency,         // валюта заказа (поддерживается только "RUB")
    $order_id,         // номер заказа
    $recurrind_tx_id,  // id транзакции, получен при первом платеже
    $recurring_token,  // токен рекуррентной транзакции, получен при первом платеже
    $description = ''  // описание заказа (необязательно)
);
```

##### Получение статуса транзакции.

```php
$form = new PaymentForm($merchant_id, $secret_key, $is_test);
print_r($form->get_transaction_info($transaction_id));
```
